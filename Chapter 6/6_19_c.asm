#я прекрасно осознаю, что такой алгоритм максимально неэффективен, и делал так только ради тренировки.
fib:                  #метка функции для вычисления чисел Фибоначи
  addi  t0, zero, 1   #инициализация временной переменной для проверки условия
  blt   t0, a0, ELSE  #проверка условия n>1
  ret                 #возврат из функции если n<=1
ELSE:                 #метка если n>1
  addi  sp, sp, -16   #выделение фрейма стека
  sw    ra, 12(sp)    #сохранение регистра возврата

  sw    a0, 8(sp)     #сохранение n перед рекурсивным вызовом
  addi  a0, a0, -1    #задача аргумента (n-1) для первого рекурсивного вызова
  call  fib           #рекурсивный вызов
  lw    t0, 8(sp)     #восстановление n из памяти
  sw    a0, 8(sp)     #запись возвращённого значения первой рекурсивной функции
  addi  a0, t0, -2    #задача аргумента (n-2) для второго рекурсивного вызова
  call  fib           #второй рекурсивный вызов
  lw    t0, 8(sp)     #восстановление возвращённого значения первой рекурсивной функции
  add   a0, a0, t0    #сложение результатов вызова рекурсивных функций
  lw    ra, 12(sp)    #восстановление указателя стека
  addi  sp, sp, 16    #освобождение пространства в стеке
  ret                 #возврат из функции

#a = [0, 1, 2]
#a[0] = a
#print(a[0][0][0][0][0][0][0][0][0])

  

''' версия для эмулятора https://www.cs.cornell.edu/courses/cs3410/2019sp/riscv/interpreter/#
addi a0, zero, 9
lui sp, 0x80000
addi sp, sp, 0xFFC
addi ra, zero, -1
fib:
  addi  t0, zero, 1
  blt   t0, a0, ELSE
  jalr zero, ra, 0
ELSE:
  addi  sp, sp, -16
  sw    ra, 12(sp)

  sw    a0, 8(sp)
  addi  a0, a0, -1
  jal ra,  fib
  lw    t0, 8(sp)
  sw    a0, 8(sp)
  addi  a0, t0, -2
  jal ra,  fib
  lw    t0, 8(sp)
  add   a0, a0, t0
  lw    ra, 12(sp)
  addi  sp, sp, 16
  jalr zero, ra, 0
'''